number,prediction,PredictionLabel,number,title,author_association,body,Target
12012,0.0,Other,12012,React.Children.toArray and React.cloneElement do not work with portal elements,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**

BUG or undefined behaviour

**What is the current behavior?**

Doing
```
React.Children.toArray(
  ReactDOM.createPortal(...)
)
```

fails with:
```
Objects are not valid as a React child (found: object with keys {$$typeof, key, children, containerInfo, implementation}). If you meant to render a collection of children, use an array instead.
```

Namely, the following complete snippet fails:

```jsx
import React from 'react';
import { render, createPortal } from 'react-dom';

const RenderChildren = ({ children }) => {
  children = React.Children.toArray(children)
  return <h1>Renders children with toArray: {children}</h1>
}


const App = () => ( 
  <RenderChildren name=""CodeSandbox"">
    {createPortal(<div>rendered in portal</div>, document.getElementById('portal'))}
  </RenderChildren>
);

render(<App />, document.getElementById('root'));
```

while the following one, which wraps the portal in another element works just fine

```jsx
import React from 'react';
import { render, createPortal } from 'react-dom';

const RenderChildren = ({ children }) => {
  children = React.Children.toArray(children)
  return <h1>Renders children with toArray: {children}</h1>
}


const App = () => ( 
  <RenderChildren name=""CodeSandbox"">
    <div>
        {createPortal(<div>rendered in portal</div>, document.getElementById('portal'))}
    </div>
  </RenderChildren>
);

render(<App />, document.getElementById('root'));

```
**What is the expected behavior?**
I am aware that `createPortal` is a new feature, but in the best case scenario it should be possible to use it everywhere other valid nodes are accepted.

The same thing is happening for `React.cloneElement(ReactDOM.createPortal(....))` - it's probably weird to try and clone a portal 😄  - but maybe we should specify in the `createPortal` documentation that it cannot be cloned, at least for now. Should I open a PR for that?

Let me know your thoughts

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

I'm using React 16.*",Feature
12197,1.0,Support,12197,Warn on ComponentName.PropTypes,CONTRIBUTOR,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**
Feature

**What is the current behavior?**
Sometimes, when my boss is stressing me out, I add prop types this way:

```js
const MyButton = props => <button>{/* some fancy implementation */}</button>;
MyButton.PropTypes = { children: node.isRequired };
```

Notice the upper-case P in PropTypes. React does not warn me about this typo.

**What is the expected behavior?**

I'd love to get a warning about this (and `DefaultProps` for that sake) whenever I mis-type them.

I would actually love to implement a pull request for this, but I couldn't find anywhere else where you're warning about static properties like these. Where would you like me to put this code?",Other
12238,0.0,Other,12238,New React component definition with autobind,NONE,"I don't know what exactly is planned, but auto bind for methods would be nice. Yeah, I know property initializers, still, a user should not have to think about that. I suppose a state should be stored in an object, not in a closure because of logs, and component should be an object ideally. Nevermind, feel free to close this ""issue"" without any explanation, I am just curious the reasoning behind a new design.",Support
12301,0.0,Other,12301,state change in td element,NONE,"Displaying tabular rows, when setting data in td element, on state change it displays only the currently updated td element data..all the other ones go missing from screen. When the same thing is placed within text box in each td element things work fine.

Following is sample the code :

Working code :
`<tr key={id}> `
`<td> <input  value={this.state.price[id]}/> </td>`

Failing code :
`<tr key={id}> `
`<td> {this.state.price[id]} </td>`",Support
12340,0.0,Other,12340,jsx's close tag name may optional?,NONE,"
**Do you want to request a *feature* or report a *bug*?**
*feature*

**What is the current behavior?**
```html
<div>
  <p>some text</p>
  <hr/>
</div>
```

**What is the expected behavior?**
because the html tag always pairs, so if simple write better?
```html
<div>
  <p>some text</>
  <hr/>
</>
```",Feature
12372,1.0,Support,12372,react 16.3 new context API basic intent,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**
misunderstanding

**What is the current behavior?**
Impossible to render a component which is a provider furnished by createContext function
trying to follow those articles :  
[whats new in react](https://medium.com/@baphemot/whats-new-in-react-16-3-d2c9b7b6193b)
[react new context API](https://medium.com/dailyjs/reacts-%EF%B8%8F-new-context-api-70c9fe01596b)


**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
[code sandBox example](https://codesandbox.io/embed/k591mqw98o)
sourceCode of codeSandBox :  
```
import React, { Component, createContext } from ""react"";
import { render } from ""react-dom"";

const CartState = createContext({
  open: false
});

class CartStateProvider extends Component {
  state = { open: false };

  render() {
    return (
      <CartState.Provider value={this.state.open}>
        {this.props.children}
      </CartState.Provider>
    );
  }
}

class App extends Component {
  render() {
    return (
      <div>
        <CartStateProvider>
          <CartState.Consumer>
            {({ open }) => {
              return <div>{open ? ""open"" : ""closed""}</div>;
            }}
          </CartState.Consumer>
        </CartStateProvider>
      </div>
    );
  }
}

render(<App />, document.getElementById(""root""));
```

**What is the expected behavior?**
It should render ""closed""

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
i'm testing with react 16.3.0-alpha.1, as it is new feature, it cannot work in previous releases
",Other
12485,1.0,Support,12485,Error still logged to console when caught by error boundary in testing,NONE,"**Do you want to request a *feature* or report a *bug*?**

I'm not quite sure if feature/bug... I have an error boundary, and I want to test that it works correctly, but it produces a big `console.error` and there doesn't seem a great way to get around it.

**What is the current behavior?**

When an error is captured by the error boundary, it still logs to console during tests, making it look like something failed but it is expected (because I am testing error boundary) in this case.

```
    console.error node_modules/react-dom/cjs/react-dom.development.js:9747
      The above error occurred in the <Child> component:
          in Child (at ErrorBoundary.test.jsx:20)
          in ErrorBoundary (created by WrapperComponent)
          in WrapperComponent

      React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.
```

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

Error  Boundary:
```jsx
import React from ""react"";
import PropTypes from ""prop-types"";

export default class ErrorBoundary extends React.Component {
  static propTypes = {
    children: PropTypes.oneOfType([
      PropTypes.node,
      PropTypes.arrayOf(PropTypes.node)
    ]).isRequired,
    render: PropTypes.func.isRequired
  };

  state = {
    hasError: false,
    error: null,
    errorInfo: null
  };

  componentDidCatch(error, errorInfo) {
    this.setState({ hasError: true, error, errorInfo });

    // if we have Bugsnag in this environment, we can notify our error tracker
    if (window.Bugsnag) {
      window.Bugsnag.notify(error);
    }
  }

  render() {
    if (this.state.hasError) {
      return this.props.render(this.state.error, this.state.errorInfo);
    }
    return this.props.children;
  }
}
```

ErrorBoundary.test.jsx
```jsx
import ErrorBoundary from ""./ErrorBoundary"";

const Child = () => {
  throw ""error"";
};

it(""catches error and renders message"", () => {
  const wrapper = mount(
    <ErrorBoundary render={() => <div>Error has occurred</div>}>
      <Child />
    </ErrorBoundary>
  );

  expect(wrapper.text()).toEqual(""Error has occurred"");
});
```

**What is the expected behavior?**

I'm not sure exactly... here is a way I can sort of temporarily pause `console.error` logging during the course of the test, but it seems messy. How should error boundaries be tested?

Here is a *hacky* solution:
```jsx
import ErrorBoundary from ""./ErrorBoundary"";

const Child = () => {
  throw ""error"";
};

const pauseErrorLogging = codeToRun => {
  const logger = console.error;
  console.error = () => {};

  codeToRun();

  console.error = logger;
};

it(""catches error and renders message"", () => {
  pauseErrorLogging(() => {
    const wrapper = mount(
      <ErrorBoundary render={() => <div>Error has occurred</div>}>
        <Child />
      </ErrorBoundary>
    );

    expect(wrapper.text()).toEqual(""Error has occurred"");
  });
});
```

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.2 (with enzyme 3.3)
",Other
12551,1.0,Support,12551,New Context Provider may block Old context propagation if children are constant,CONTRIBUTOR,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**

Bug

**What is the current behavior?**

It seems that, if the children of a new-style `React.createContext()` context `Provider` are constant, the `Provider` can block updates from old-style `this.context` context providers from propagating to `this.context` consumers.

This sandbox demonstrates the issue. Clicking the button with a number will correctly increment the `Root`'s `state` and `context`, but the update is only propagated to the `Child3`'s `context` (and its button) when the ""Colors!"" button is clicked, as it causes an update to the `value` of the new-style `Provider`:

https://codesandbox.io/s/ol4lpokpjy

<details>
<summary>Copy of the source code in the sandbox</summary>

```jsx
import PropTypes from ""prop-types"";
import React from ""react"";
import ReactDOM from ""react-dom"";

class Root extends React.Component {
  constructor(props: {}) {
    super(props);
    this.state = {
      count: 0
    };
    this.countUp = this.countUp.bind(this);
  }

  getChildContext() {
    return {
      ...this.context,
      count: this.state.count,
      countUp: this.countUp
    };
  }

  render() {
    return this.props.children;
  }

  countUp() {
    this.setState(({ count }) => ({ count: count + 1 }));
  }
}

Root.childContextTypes = {
  count: PropTypes.number.isRequired,
  countUp: PropTypes.func.isRequired
};

const ctx = React.createContext();

class Child1 extends React.Component {
  constructor(props: { onClick(): void }) {
    super(props);
    this.state = {
      color: randomHexColor(),
      newColor: this.newColor.bind(this)
    };
  }

  render() {
    return (
      <ctx.Provider value={this.state}>{this.props.children}</ctx.Provider>
    );
  }

  newColor() {
    const color = randomHexColor();
    this.setState(() => ({ color }));
  }
}

function randomHexColor() {
  const colorStr = Math.floor(Math.random() * (Math.pow(2, 24) - 1)).toString(
    16
  );
  return ""#000000"".slice(0, -colorStr.length) + colorStr;
}

class Child2 extends React.Component {
  render() {
    return (
      <ctx.Consumer>
        {ctx => (
          <React.Fragment>
            <Child3 color={ctx.color} />
            <button onClick={ctx.newColor}>Colors!</button>
          </React.Fragment>
        )}
      </ctx.Consumer>
    );
  }
}

class Child3 extends React.Component {
  render() {
    return (
      <button
        style={{ color: this.props.color }}
        onClick={this.context.countUp}
      >
        {this.context.count}
      </button>
    );
  }
}

Child3.contextTypes = {
  count: PropTypes.number.isRequired,
  countUp: PropTypes.func.isRequired
};

ReactDOM.render(
  <Root>
    <Child1>
      <Child2 />
    </Child1>
  </Root>,
  document.getElementById(""root"")
);

```

</details>

**What is the expected behavior?**

Both old-style and new-style context updates should coexist.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

16.3.1; also broken in 16.3.0.

---

This seems to only happen if the `children` of the `Provider` are constant, which is what happens when the children are provided on the first and only `ReactDOM.render` call. If `Child1` is updated to directly use `<Child2/>` instead of `{this.props.children}`, the problem does not happen.

This can also be a problem when using a production optimization that hoists constant elements outside the Component if the specified children are constant, which would even defeat the fix/workaround for the example above.",Bug
12693,1.0,Support,12693,react-test-renderer.create does not work properly with forwardRef components,NONE,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
If you try to access the `.root` of a component tree of a component created with `forwardRef`, you will get an error

> `Unexpected object passed to ReactTestInstance constructor`

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

A minimal example is simply a component created with `forwardRef`:

```js
import React from ""react"";

export default React.forwardRef(() => <div>hello</div>);
```

Now if you try to use `create` from `react-test-renderer` and access `.root`, you will get

> Unexpected object passed to ReactTestInstance constructor (tag: 14). This is probably a bug in React.

```js
import React from ""react"";
import { create } from ""react-test-renderer"";

import Hello from ""./Hello"";

it(""test forwardRef component"", () => {
  const tree = create(<Hello />);
  expect(tree.root);
});
```

https://codesandbox.io/s/vm98x95wx5

**What is the expected behavior?**
You should be able to create components created with forwardRef with the test renderer.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.3 using jest (forwardRef did not exist previously).",Bug
12723,0.0,Other,12723,The findByType method from react-test-renderer doesn't find ref-forwarding components,CONTRIBUTOR,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
In tests, if the component passed to `root.findByType` was created using `forwardRef` it can't be found.

If I use `root.find` to loop over all the nodes and log `.type` I see that the ref-forwarding-component is skipped entirely.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/k0o70vjv07?module=%2Fsrc%2Findex.test.js

I expect the second test to work like the first, however the second test is failing.

**What is the expected behavior?**
This may just be the way that `forwardRef` works, but the reason I expected it to work is I'm using it to make wrapped controls, like the `<FancyButton>` example from the documentation. When writing tests I want to be able to find a `FancyButton` and test it's besing passed the correct props, and not have to check that the DOM rendered by `FancyButton` is correct; that's already being tested in `fancy-button.test.js`

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Using React 16.3.2, failing in Chrome and Node 8.11.0

I've tried all the `16.3.x` versions in codesandbox and they all failed.",Bug
12774,0.0,Other,12774,this.state doesn't  get the current state properly,NONE,"Related to this issue 
https://github.com/dmtrKovalenko/material-ui-pickers/issues/396#issuecomment-387972773

I found a work around by checking the state out of the onChange. But i can't figure out why it behaves like that in the first place.

Example:
https://codesandbox.io/s/2zrx49zwjj",Support
13410,1.0,Support,13410,Investigate why select._wrapperState.initialValue is necessary,CONTRIBUTOR,"Uncovered during @raunofreiberg's select work (#13389).

`select._wrapperState.initialValue` is only ever assigned, never referenced. Can it be removed?

Example:
https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMFiberSelect.js#L191

It would be great if someone could investigate this, and figure out if it can be removed.",Bug
13715,0.0,Other,13715,Improved stack trace,NONE,"**Do you want to request a *feature* or report a *bug*?**
*feature*

**What is the current behavior?**

* The usability of the current stack trace for components with native dom elements can be improved.
![image](https://user-images.githubusercontent.com/43165983/45943746-33217400-c005-11e8-953b-2e016bd10f9d.png)
* In this example it tells me that there are 3 divs, followed by a select tag (Not sure why select's display name is showing as the components' name itself) and then option tag. But this same structure exists in lot of places in the component.

**What is the expected behavior?**
* Stack trace with line number/some other way to pinpoint it's location (like id/class if provided??) is desired

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
OS: Ubuntu 18.04
React: 16.2.0",Support
13819,1.0,Support,13819,How to send a notification to specific user and handle it,NONE,"I'm an android and iOS developer. 
on android and ios programming I can open a ***specific page*** when user click on the notification.

for example, this is a sample JSON string from the server side to clients:

    ""data"":{
      ""pages"":""home""
    }

when I receive this notification I can open the `home` page.

I want to handle my react pages when a notification will receive.

Is it possible to handle this action? or on the web application, user just can see the message from notification?
",Other
13845,0.0,Other,13845,[npm:create-react-class] Forwarding refs,NONE,"https://reactjs.org/docs/react-without-es6.html doesn't seem to explain how to use forwarding refs:

https://reactjs.org/docs/forwarding-refs.html

Does the render function in the class have to have the new props argument?",Support
13944,0.0,Other,13944,Cannot be used new contextType API in constructor?,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?** *feature* 

**What is the current behavior?** Using `Component.contextType`, `this.context` keeps `null` in class component's constructor.

**What is the expected behavior?** 

-  `this.context` can be obtained in constructor
- if implementing of the feature is inappropriate, write in documentations that `this.context` cannot be used in constructor.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?** React 16.6 (older React doesn't have `Component.contextType`) in Chrome 70 (Windows 7)
",Bug
13985,1.0,Support,13985,Warn if ReactDOM.createPortal is inside a noscript or other text content tag,CONTRIBUTOR,"**Do you want to request a *feature* or report a *bug*?**
bug

**What is the current behavior?**

When calling `ReactDOM.createPortal` from within a `<noscript />`, nothing happens, no error is logged.

```javascript
ReactDOM.render(
  <noscript>
    {ReactDOM.createPortal(""yo"", modalNode)}
  </noscript>,
  appNode
);
```

**What is the expected behavior?**

Whether:
- warn that it doesn't work (it worked in the previous version)
- render the portal

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

- React 16.5.0 & more recent
- Reproducible in every browser

**Repro**
https://jsfiddle.net/bloodyowl/n5u2wwjg/223296/",Feature
14002,0.0,Other,14002,Safari Devtools flooded with security errors on react-dom selection work with iframes with diff origins,NONE,"hey folks, looks like [this code](https://github.com/facebook/react/commit/b565f495319750d98628425d120312997bee410b) added small issue with safari and it could flood devtools console output with messages like this:
<img width=""875"" alt=""screenshot 2018-10-26 at 15 25 33"" src=""https://user-images.githubusercontent.com/778908/47569863-0e3a5c80-d935-11e8-8e59-8d95d35ba131.png""> 
As I understand it happens [here](https://github.com/facebook/react/commit/b565f495319750d98628425d120312997bee410b#diff-a654f37b01573fc8006b426d56ad53ceR50) and I see you catch the error, but safari still adds the error message if you have iframes with different origin",Bug
14009,0.0,Other,14009,React + GSAP -> Animation doesn't work with Build production,NONE,"### Is this a bug report?
- Maybe Yes? || A doubt :)

### Did you try recovering your dependencies?
- Yes

### Which terms did you search for in User Guide?
- Yarn Build: Animation Failing

### Environment

`npx create-react-app gsapApp`

**package.json**

```javascript

""homepage"": ""."",
""dependencies"": {
  ""gsap"": ""^2.0.2"",
  ""react"": ""^16.6.0"",
  ""react-dom"": ""^16.6.0"",
  ""react-scripts"": ""^2.0.5""
},
""scripts"": {
  ""start"": ""react-scripts start"",
  ""build"": ""react-scripts build"",
  ""test"": ""react-scripts test --env=jsdom"",
  ""eject"": ""react-scripts eject""
},
""devDependencies"": {},
""browserslist"": [
  "">0.2%"",
  ""not dead"",
  ""not ie <= 11"",
  ""not op_mini all""
]

```

**manifest.json**
```javascript

""start_url"": "".""

```

### Steps to Reproduce

1. When running the project with the server with `react-scripts start`, the animation runs perfectly. : D
2. However ... when creating the bundle for production, using the react-scripts build command the animation simply does not work: :'(
3. I'll provide the code below to show it happening

### Expected Behavior

- That the animation works normally

### Actual Behavior

- Animation does not happen.
In the video below:
1) On the Left: project running with `yarn start`, adding 2 seconds of delay to view a console along with animation start.
2) On the Right: project running on a static server withe the build folder after run `yarn build`. The console after 2 seconds runs, the animation does not.

![react gsap](https://user-images.githubusercontent.com/15070031/47618498-8d08d400-dab2-11e8-8e28-2a147bf01eee.gif)

### Reproducible Demo

**App.js**

```javascript

import React, { Component } from 'react';
import { TweenLite } from 'gsap/all';

class App extends Component {

  componentDidMount() {
    setTimeout(() => {
      console.log('animate init', true)
      TweenLite.to(this.myPRef, 2, {
        x: 200
      })
    }, 2000)
  }

  render() {
    return (
      <p ref={ref => this.myPRef = ref}>React + GSAP</p>
    );
  }
}

export default App;

```
Any idea? :)

**p.s**: I'll post this behavior also on GSAP's and facebook/create-react-app's Github, to see if this could be a GSAP or Build with CRA bundle-related issue.

Thanks for the help, 
Alex.",Support
14160,0.0,Other,14160,XSS Protection: href Object not being html escaped as a props,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**
I would like to request a bug.

**What is the current behavior?**
From what I know, it is possible to inject object in props. However, this object seems to be html escaped when inserted into the DOM from my observation. 

Thus, if I try to add an onerror=alert('XSS') in a <img {this.props.dangerousAtt /> tag through a props, this is gonna be escaped when rendered. Then, I realized that inserting an id='test' is totally possible with a props. So I thought only dangerous javascript injectable attributes are escaped such as onerror,  onload, ...

However, I realized that the href=javascript:alert('1') is not escaped when inserted through a props. The javascript gets executed. Here, I thought it might a bug. 


**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
```
class App extends Component {
  render() {
  const href = {href: ""javascript:alert('1')""};
    return (
      <div>
      <a {...href}>Click here</a>     
      </div>
    ); 
}

ReactDOM.render(<App />, document.getElementById('root'));

```


**What is the expected behavior?**

I would expect the href object to be escaped as a props, so being treated exactly like onerror or other javascript attributes. 

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React version: 16.6.0
Browser: Chrome 70.0.3538.77",Support
14266,0.0,Other,14266,props with same key and value,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Short form for props key and value**
for example:
*Instead of this*:
```Javascript
......
const { name, age, photoURI } = this.state
return (
  <Person name={name} age={age} photoURI={photoURI} />
)
........
```
this:
```Javascript
.......
const { name, age, photoURI } = this.state
return (
  <Person *name *age *photoURI />
) 
........
```

or even other way so that we don't have to write same key and value.
maybe a doller ($) sign ``` <Person $name /> ``` and any other way

like in es2015 there is a fix for:
```Javascript
const person = {
  name: name,
  age: age,
  photoURI: photoURI
}
// to
const person = { name, age, photoURI }
```

Pardon my English",Support
14355,0.0,Other,14355,[Mouse Events] onMouseDownCapture is not stopping capture phase propagation,NONE,"**Bug report**

**The current documentation has and I quote https://reactjs.org/docs/events.html**
** -To register an event handler for the capture phase, append Capture to the event name; for example, instead of using onClick, you would use onClickCapture-**

**I tried with this https://jsbin.com/hilome/edit?js,output and**

`<div id=""grandparent"" onClickCapture={this._handleClickCapture}>
          <div id=""parent"" onClick={this._handleClickBubble}>
            <button id=""elem"" onClick={this._handleClick}>Click me!</button>
          </div>
        </div>`

**if I change onClickCapture with onMouseDownCapture the stopPropagation() method does not prevent capture phase any more**


**What is the expected behavior?**

**I would expect that stopPropagation() stops the propagation to its children as it works with onClickCapture event**
",Support
14496,0.0,Other,14496,Local environment is not a problem after the line Error: Minified React error #31; visit,NONE,"react-dom.production.min.js:179 Error: Minified React error #31; visit https://reactjs.org/docs/error-decoder.html?invariant=31&args[]=object%20with%20keys%20%7Bmodule%2C%20planList%2C%20taskList%7D&args[]= for the full message or use the non-minified dev environment for full errors and additional helpful warnings.
",Support
14537,1.0,Support,14537,Suggestion: make version of react only with hooks to reduce bundle size,NONE,"I think that should be a version of react without component stuff to reduce bundle size and another version with component and hooks 
Is that would make a big effect of the bundle size or they are just some KBs ?",Other
14544,1.0,Support,14544,`yarn flow` stuck at merging on Window10,CONTRIBUTOR,"**Do you want to request a *feature* or report a *bug*?**
a bug

**What is the current behavior?**
See #14519 first.

And i tested on a Linux machine,same node version,same yarn version,same npm version,and same operation.
On Linux,`yarn flow` works well.
I tested on another Window10 machine,also fail.

So i think this is a **bug** related to flow,win10 and react source code,not my own problem.

",Other
14731,1.0,Support,14731,useState inside a context provider not properly read when called from timeout,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**

Looks like a **bug**.

**What is the current behavior?**

I have a simple context set up to manage a global store. When implementing this context as a functional component with the useState hook, calls to my setStore function from inside a timeout are seeing old versions of the store and updating it incorrectly.

Possibly a duplicate of #14010 but I don't see why the value of my store should be getting saved by the closure. The closure created by the setTimeout can't see the value of store, so it shouldn't be captured.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

[https://codesandbox.io/s/mnxr754oy](https://codesandbox.io/s/mnxr754oy)

Refresh the page in the sandbox and click the ""Increment otherVal"" button a few times. After 3 seconds, a timeout fires in ChildThree that sets myVal to 42 but doesn't touch otherVal; however, the changes made by incrementing otherVal get blown away. This doesn't happen with changes prompted by onClick events (as you can test by clicking ""Set myVal to 42"" on the bottom), only timeouts.

The context implementation is in `store.js`. If you swap out the functional StoreProvider with the commented out class version, everything works as expected.

It's possible that I'm doing something wrong with how my closures are being created in the functional StoreProvider but I can't see why.

**What is the expected behavior?**

The context provided function setStore should be seeing the correct copy of the state returned by the hook.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Tested in Chrome/Firefox/Edge on React 16.9.0-alpha.1",Other
14856,0.0,Other,14856,Chrome 73 breaks wheel events,NONE,"Similar to #8968, but for the `wheel` and `mousewheel` events. They are now passive by default for root elements in Chrome 73 (currently beta) which means React apps that have custom scrolling/zooming behaviors will run into issues.

The quick fix may be to manually add event listeners with `{passive: false}` but has the React team considered if this should be configurable for the React event handler?

Blog post from the Chrome team here: https://developers.google.com/web/updates/2019/02/scrolling-intervention",Bug
14904,1.0,Support,14904,controlled input cursor jumps to end (again),NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**

Bug

**What is the current behavior?**

when typing in a controlled input, the cursor always jumps to the end. This was an old issue that seems to have resurfaced.

[this code pen](https://codepen.io/gaearon/pen/VmmPgp?editors=0010) used in the docs [here](https://reactjs.org/docs/forms.html#controlled-components)  has the problem in all browsers as far as I have been able to test.

**What is the expected behavior?**

because we are using the state to update the component as soon as it's changed, the input element should be able to keep the cursor in the same place.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

I'm at latest (16.8.2) and I tested on Chrome, FireFox, and Edge on Windows

as far as I know, this was working at some point, though I don't know how long ago. possibly even before ""Fiber""

",Bug
14946,0.0,Other,14946,Feature request: `useShouldUpdate` hook,NONE,"**Do you want to request a *feature* or report a *bug*?**
Request a feature

It is currently impossible to let React know that the output of a **functional component** is not affected by the current change. I think that it would be great to have a hook for enabling this capability. In other words: having the SCU functionality in functional components through a hook.

I'm aware of the existence of `React.memo` and I know that it is possible to accomplish the same thing by splitting the logic in 2 different functional components... as long as we enhance the ""base"" component with `React.memo`. However, I still think that the hook that I'm suggesting would be a pretty nice addition.

I guess that it's a good idea to show an example of a real case where this hook would be helpful. So, here we go:

I don't normally use the official react-redux bindings. Instead, I have my own version of the `connect` HOC which has a more limited (and slightly different) API, that better suits my needs. This makes my version a bit more performant and a lot lighter. Regardless of whether it is a good idea not to use the official react-redux bindings, the following example illustrates the benefit of having the hook that I'm suggesting.

This is the current implementation of my custom ""connect"" HOC:

```js
const emptyObj = {};                                                           
const alwaysEmpty = () => emptyObj;                                            
                                                                               
export default (fromStateProps_, fromActionProps = emptyObj, mapper) => {      
  const dependsOnProps = fromStateProps_ && fromStateProps_.length !== 1;      
  const fromStateProps = !fromStateProps_ ? alwaysEmpty : fromStateProps_;     
                                                                               
  return BaseComponent => {                                                    
    const MBaseComponent = memo(BaseComponent);                                
                                                                               
    return props => {                                                          
      const dependantProps = dependsOnProps ? props : emptyObj;                
                                                                               
      const {state, dispatch} = useContext(context);                           
      const stateProps = useMemo(() => fromStateProps(state, dependantProps), [
        state,                                                                 
        dependantProps,                                                        
      ]);                                                                      
      const actionProps = useMemo(() => {                                      
        const res = {};                                                        
        Object.entries(fromActionProps).forEach(([name, aCreator]) => {        
          res[name] = (...args) => dispatch(aCreator(...args));                
        });                                                                    
        return res;                                                            
      }, [dispatch]);                                                          
                                                                               
      return useMemo(() => {                                                   
        const finalProps = mapper                                              
          ? mapper(stateProps, actionProps, props)                             
          : {...props, ...stateProps, ...actionProps};                         
        return <MBaseComponent {...finalProps} />;                             
      }, [actionProps, props, stateProps]);                                    
    };                                                                         
  };                                                                           
};                                                                             
```

It works great (for me). However, I would much rather to be able to implement it like this:

```js
const emptyObj = {};                                                           
const alwaysEmpty = () => emptyObj;                                            
                                                                               
export default (fromStateProps_, fromActionProps = emptyObj, mapper) => {      
  const dependsOnProps = fromStateProps_ && fromStateProps_.length !== 1;      
  const fromStateProps = !fromStateProps_ ? alwaysEmpty : fromStateProps_;     
                                                                               
  return BaseComponent => {                                                    
    const componentFn = BaseComponent.prototype                                
      ? p => <BaseComponent {...p} />                                          
      : p => BaseComponent(p);                                                 
                                                                               
    return props => {                                                          
      const dependantProps = dependsOnProps ? props : emptyObj;                
                                                                               
      const {state, dispatch} = useContext(context);                           
      const stateProps = useMemo(() => fromStateProps(state, dependantProps), [
        state,                                                                 
        dependantProps,                                                        
      ]);                                                                      
      const actionProps = useMemo(() => {                                      
        const res = {};                                                        
        Object.entries(fromActionProps).forEach(([name, aCreator]) => {        
          res[name] = (...args) => dispatch(aCreator(...args));                
        });                                                                    
        return res;                                                            
      }, [dispatch]);                                                          
                                                                               
      useShouldUpdate([actionProps, props, stateProps]);                       
                                                                               
      const finalProps = mapper                                                
        ? mapper(stateProps, actionProps, props)                               
        : {...props, ...stateProps, ...actionProps};                           
                                                                               
      return componentFn(finalProps);                                          
    };                                                                         
  };                                                                           
};                                                                             
```

How do you feel about this suggestion? Too weird? 😄 

Thanks,

Josep",Support
14956,1.0,Support,14956,"Element.createShadowRoot is deprecated and will be removed in M73, around March 2019. Please use Element.attachShadow instead",NONE,"include.preload.js:1 [Deprecation] Element.createShadowRoot is deprecated and will be removed in M73, around March 2019. Please use Element.attachShadow instead. See https://www.chromestatus.com/features/4507242028072960 for more details.

**What is the expected behavior?**

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
",Other
15054,0.0,Other,15054,useImperativeHandle callback never called (when rendering w/ enzyme),NONE,"**Do you want to request a *feature* or report a *bug*?**
bug

**What is the current behavior?**

I have the code:

```
function Form(props, ref) {

  React.useImperativeHandle(ref, () => {
    debugger;
    return {
      setErrors: () => {},
    };
  });
}

export default React.forwardRef(Form);
```

When I use the component, the callback passed to `useImperativeHandle` is never called. (The debugger statement is never hit).

The code that I have using the component is:

```
import {mount} from 'enzyme';

describe('Form component', () => {
  test('exposes a ref', async () => {
    let formRef;
    mount(<Form ref={ref => (formRef = ref)}>{() => <span>test</span>}</Form>);
    await pause(500); // this is just a setTimeout to give time for the hooks to run.
    expect(formRef.setErrors).toBeDefined();
  });
```

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

https://codesandbox.io/s/v8rqy75mn5

**What is the expected behavior?**

Callback should be called and returned value should be used as the ref.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

```
    ""react"": ""16.8.0-alpha.1"",
    ""react-dom"": ""16.8.0-alpha.1"",
    ""enzyme"": ""3.8.0"",
    ""enzyme-adapter-react-16"": ""1.8.0"",
```
",Support
15056,1.0,Support,15056,Controlled contentEditable element contents not updated when state changes,NONE,"**Do you want to request a *feature* or report a *bug*?**
Bug

**What is the current behavior?**
An element with contentEditable does not update the content when state updates.

Reproduce:
https://codesandbox.io/s/kk421m2jmr
1. Type something in the contentEditable div.
2. Click reset
3. Expected div to contain ""TEXT RESET!""

**Which versions of React
16.8.4",Other
15209,0.0,Other,15209,useState function as initial state gets executed,NONE,"**Do you want to request a *feature* or report a *bug*?**
bug

**What is the current behavior?**
When passing a function as the initial value to the useState hook the function gets executed.

Please see the following example:
https://codesandbox.io/s/vyj88kjn4l

**What is the expected behavior?**
The function is not executed.

Why does the function get executed here?

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.8.3",Support
15236,0.0,Other,15236,How test componentDidUpdate lifecycle method with test-renderer?,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**

**What is the current behavior?**

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

**What is the expected behavior?**

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
",Support
15513,0.0,Other,15513,Allow ReactNode as a type for the child of <option/>,NONE,"**Do you want to request a *feature* or report a *bug*?**
Feature

**What is the current behavior?**
Currently, the options element only allows types number and string. 

**What is the expected behavior?**
An option should allow for a ReactNode as a child in addition to a number + string. 

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
All versions.
All browser types.
To the best of my knowledge, no.

p.s. This is my first feature request here, so let me know if I need to adjust the feature request in any way. ",Support
15527,1.0,Support,15527,Apparent memory leak using hooks,NONE,"**Do you want to request a *feature* or report a *bug*?**

Maybe a bug. Maybe I'm just running into a weird edge case.

**What is the current behavior?**

I have a situation where using a combination of `useEffect`, `useCallback`, and having a function in the actual component render is causing a sort of memory leak.
The current render of the component seems to hang on to references of past renders of the component. (more details in the reproduction sample repo)

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem.**

I think I have this minimized about as much as I can:
https://github.com/rally25rs/react-mem

It's a basic `create-react-app` project, so you can just `yarn install && yarn start` it. There is some explanation/instructions in the web page that it renders.

The `src/VirtualizedTable.js` file is the key file to look at.

**What is the expected behavior?**

As best as my brain can comprehend, memoized references should be getting cleared as the component props change and data should be garbage collected (but it isn't).

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

* Chrome
* react@16.8.6
",Other
15723,1.0,Support,15723,Strange onScroll behaviour,NONE,"**Do you want to request a *feature* or report a *bug*?**

Possible bug

**What is the current behavior?**

onScroll callback on parent element fires when children element is scrolled.
Native listener working as expected, thought.

Example with reproduction
https://codesandbox.io/s/kk3th

Just try to scroll little box with items.

**What is the expected behavior?**

I am not sure if this behaviour is correct, but it was unexpected for me, so it might be a bug.
I was not expecting onScroll to fire at all.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

""react"": ""16.8.6""
macOs Mojave 10.14.5

Did not tried any other versions
",Bug
15856,1.0,Support,15856,No warning or Error on component mounting itself,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**
bug

**What is the current behavior?**
When mounting a component within itself, there is no warning or error, and leads to an infinite loop until the browser tab crashes. 

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
```
const Card = (
  <Card>test</Card>
);

<Card />
```

**What is the expected behavior?**
warning in dev tools or throws an error

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
""react"": ""^16.8.1"",
",Other
16093,1.0,Support,16093,onClick not firing,NONE,"I can't seem to get the onClick event to fire at all. I've reduced my app to the following file: 

index.js:
```
import React from 'react'
import { render } from 'react-dom'

const Index = () => {
  console.log('rendered')
  return <button onClick={() => console.log('hello')}>test</button>
}

render(
  <Index />,
  document.getElementById('app')
)
```
I get 'rendered' output to the console, but nothing when I click on the button.

package.json:
```
{ 
...
devDependencies {
    ...
    ""react"": ""^16.8.4"",
    ""react-dom"": ""^16.8.4"",
     ...
}
...
}
```
building inside a Laravel 5.2 app via: 
`browserify -t [ babelify --presets [ react es2015 ] ] resources/js/react/index.js -o public/js/test.js`
",Other
16305,1.0,Support,16305,Different Suspense Behavior in ReactDOM.render vs React.createRoot().render,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**

bug

**What is the current behavior?**

Throwing a resolved promise inside an app mounted with `React.unstable_createRoot().render()` triggers the suspense fallback render, defocusing inputs in the app.

In contrast, throwing an immediately resolved promise inside the same app rendered with  `ReactDOM.render()` does not trigger the suspense fallback render.

Here's a small reproduction showing the different behaviors: 
```javascript
import React from ""react"";
import ReactDOM from ""react-dom"";

let cache = {};

function MyApp() {
  let [text, setText] = React.useState(""edit this"");

  if (!cache[text]) {
    cache[text] = true;
    throw Promise.resolve();
  }

  return <input value={text} onChange={e => setText(e.target.value)} />;
}

let fallback = <div style={{ background: ""red"" }}>fallback</div>;
let dom = (
  <React.Suspense fallback={fallback}>
    <MyApp />
  </React.Suspense>
);

// Switch out the following two lines and type in the input
// to see the difference in behavior

ReactDOM.unstable_createRoot(document.getElementById(""root"")).render(dom);
// ReactDOM.render(dom, document.getElementById(""root""));

```

Here's a CodeSandbox with the code above: https://codesandbox.io/s/stupefied-cookies-qh8sy



**What is the expected behavior?**

Throwing an immediately resolved promise inside an app mounted with `React.unstable_createRoot().render()` should not trigger the suspense fallback render. Instead, it should behave identically to the app mounted with `ReactDOM.render()`.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

I'm using Chrome 75.0.3770.142, macOS 10.14.3, and react 16.9.0-alpha-0

N.B. This issue is pretty much the same as #15900, though that one seemed to have more moving parts. Please merge these if appropriate.",Other
16319,0.0,Other,16319,componentDidUpdate not triggered on changes to context,NONE,"**Do you want to request a *feature* or report a *bug*?**
Bug.

**What is the current behavior?**
Components using a context update their content upon changes to the context, but `render` and `componentDidUpdate` are not invoked even though the the components' content changes.

[Here's a JSFiddle example](https://jsfiddle.net/0ewuj8L4/). Note how the component does update (the display on screen changes), but the ""render"" messages are only logged once (to the console), while the ""update"" messages are never logged.

**What is the expected behavior?**
I guess I understand why this is happening - the components which use `Context.Consumer` don't really re-render or get updated when the context changes; only the `Context.Consumer` component does. It would still be appreciated to at least make `componentDidUpdate` get invoked somehow (automatically).

Regardless, this behavior should certainly be documented as it is quite unclear, unintuitive and not so easy to detect.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Latest React I guess? I'm running on Windows 10.0.17134.799 and Chrome 75.0.3770.142, but I believe it should replicate on other environments as well.
",Support
16358,0.0,Other,16358,React state values is shared between two components!!!,NONE,"**Bug**

I have two components: 
 `ComponentA` 

```js
class ComponentA extends Component {
  constructor(props) {
    super(props);

    this.nextCardSet = this.nextCardSet.bind(this);
    this.prevCardSet = this.prevCardSet.bind(this);
  }
  async prevCardSet() {
    const currPage = this.state.currPage - 1;
    const data = this.state.dataStore[currPage - 1];
    await this.setState({
      currPage,
      data
    });
  }

  async nextCardSet() {
    const currPage = this.state.currPage + 1;
    const data = this.state.dataStore[currPage - 1];
    await this.setState({
      currPage,
      data
    });
  }

  async componentDidMount() {
    const response = await this.getData();

    //...Doing some stuff...

    await this.setState({
      dataStore: mainData,
      data: mainData[currPage - 1],
      currPage,
      totalPages,
      isLoading: false
    });
  }

  async getData() {
    const response = await axios.get(
      'http://localhost:4000/getUserOverviewJson'
    );
    return response;
  }

  render() {
    return (
      <div>
          <Fab size=""small"" disabled={this.state.currPage === 1 ? true : false}>
            <NavigateBefore
              onClick={this.prevCardSet}
            />
          </Fab>
          <Fab
            size=""small""
            disabled={
              this.state.currPage === this.state.totalPages ? true : false
            }
          >
            <NavigateNext
              onClick={this.nextCardSet}
            />
          </Fab>
        </div>
        <CallWorkRender data={this.state.data} />
      </div>
    );
  }
}
```

`ComponentB`
```js
class ComponentB extends Component {
  constructor(props) {
    super(props);
    this.data = props.data;
  }

  getComponent = componentID => {
    const data = this.data['pageData'].shift();
    return ComponentGetter.getComponent(componentID, data);
  };

  render() {
    const { width, data } = this.props;
    this.data = data;
    const layoutConfigCallPrep = layoutConfig['1'][width];

    return (
      <FlexGrid
        layoutConfiguration={layoutConfigCallPrep}
        getComponent={this.getComponent}
      />
    );
  }
}

export default withWidth()(ComponentB);
```



In the initial load `ComponentA` sends data to `ComponentB` , so in CompB when `getComponent()` method is called it pops elements from array which it got as props.

**Now the data in array is manipulated in CompB but when I try to print the state of  CompA  its data also get manipulated. I don't understand how this weird data manipulation is happening. How does the data of one component gets altered due to data change in other component?**

*React@16.8.6*
*Windows 10*
",Support
16370,1.0,Support,16370,useEffect does not get executed again after 16.8.0-alpha1,NONE,"**Do you want to request a *feature* or report a *bug*?**
It is a bug

**What is the current behavior?**
As seen in this [codepen](https://codesandbox.io/s/react-hooks-playground-k8hxy), the useEffect gets updated every 500ms as expected and mentioned in the docs:  

> Does useEffect run after every render? Yes! By default, it runs both after the first render and after every update.

But if the react version is updated to a newer version, the timeout is called, the setCounter is called with 1 again (after the second run) which leads to a rerender of the component, but the effect is not executed as expected (2 is not called again and there is no loop).  As mentioned in the docs, use Effect without a second parameter should create a loop by calling the setTimeout again after setCount. But this is not the case for versions above 16.8.0-alpha1. Is this intended or not?

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
This [codepen](https://codesandbox.io/s/react-hooks-playground-k8hxy) works by creating a infinity loop. But updating the react version here 
![image](https://user-images.githubusercontent.com/17567991/62890380-aa5a1680-bd43-11e9-8f6c-0e026510365a.png)

will break the functionality and will not loop again because the useEffect is note executed if the prevoiusState === currentState. But the component gets rerendered anyway.

If the intended behavior is not the rerender the component if the state is the same, console.log(1) should not be called. So either the useEffect does not work as intended, or it is not intended that  useState triggers a rerender, if the state is the same.


**What is the expected behavior?**
The expected behavior is for the useEffect to be called in a loop even if the state is the same and the functional component is rendered.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
16.8.0-alpha1 works, version above it do not.

Thanks for your time and I really enjoy coding with React. Keep it up.",Other
16419,0.0,Other,16419,DevTools: react-devtools-tutorial.now.sh > editing-props-and-state have a bad state,NONE,"I don't know who's making the bug, so reporting here. I'll move to correct repo if someone helps me debug it.
**Do you want to request a *feature* or report a *bug*?**
Bug
**What is the current behavior?**
Please watch below screencast:
https://drive.google.com/file/d/1KMP44qsZ4y3MwrLLDdnOzPZ8z5mMElFP/view

1. Goto https://react-devtools-tutorial.now.sh/editing-props-and-state
2. Change the last ListItem prop to isComplete from `false` to `true`.
3. Click the checkbox in the view to change the state again from `true` to `false`.
**What is the expected behavior?**
It should just change the state of that ListItem. Instead, it's adding 3 more in the list with duplicate keys.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**

Latest React.
Mac, Chrome Version 75.0.3770.142 (Official Build) (64-bit)
",Bug
16604,0.0,Other,16604,How should we set up apps for HMR now that Fast Refresh replaces react-hot-loader?,NONE,"Dan Abramov mentioned that Devtools v4 will be making `react-hot-loader` obsolete: https://twitter.com/dan_abramov/status/1144715740983046144?s=20

> **Me:**
> I have this hook:
> ```require(""react-reconciler"")(hostConfig).injectIntoDevTools(opts);```
> But HMR has always worked completely without it. Is this now a new requirement?

> **Dan:**
> Yes, that's what the new mechanism uses. The new mechanism doesn't need ""react-hot-loader"" so by the time you update, you'd want to remove that package. (It's pretty invasive)

I can't see any mention of HMR in the Devtools documentation, however; now that `react-hot-loader` has become obsolete (and with it, the `require(""react-hot-loader/root"").hot` method), how should we set up apps for HMR in:

* React DOM apps
* React Native apps
* React custom renderer apps

I'd be particularly interested in a migration guide specifically for anyone who's already set up HMR via `react-hot-loader`.

Also, for HMR, does it matter whether we're using the standalone Devtools or the browser-extension Devtools?",Support
16957,0.0,Other,16957,Webkit inline styles dissapears in Firefox,NONE,"**Do you want to request a *feature* or report a *bug*?**: *bug*

**What is the current behavior?**
Missing `-webkit-print-color-adjust: exact;` in Firefox

**Demo**:
1. Run https://stackblitz.com/edit/react-skxixb in Firefox and Chrome
2. Check CSS for `.header`

**What is the expected behavior?**
`-webkit-print-color-adjust: exact;` should be placed in all browsers

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React 16.9.0 and 16.10.1
Windows 10
Firefox 69.0.1",Bug
17182,0.0,Other,17182,React_.createContext is not a function,NONE,"Hi so i have been trying to implement react context api into my project, After follow the steps in the guide: https://developerhandbook.com/react/build-a-complete-property-listings-page-with-react/

I ended up getting an error when i tried to display some of the information.

This is the error i got in my console log:
```

OrderListProvider.js:6 Uncaught TypeError: __WEBPACK_IMPORTED_MODULE_0_react__.createContext is not a function
    at Object../src/context/OrderListProvider.js (OrderListProvider.js:6)
    at __webpack_require__ (bootstrap 39db4eed0e38b5656c68:678)
    at fn (bootstrap 39db4eed0e38b5656c68:88)
    at Object../src/components/Home.js (FetchData.js:3)
    at __webpack_require__ (bootstrap 39db4eed0e38b5656c68:678)
    at fn (bootstrap 39db4eed0e38b5656c68:88)
    at Object../src/App.js (fetch.js:461)
    at __webpack_require__ (bootstrap 39db4eed0e38b5656c68:678)
    at fn (bootstrap 39db4eed0e38b5656c68:88)
    at Object../src/index.js (index.css?f255:26)
    at __webpack_require__ (bootstrap 39db4eed0e38b5656c68:678)
    at fn (bootstrap 39db4eed0e38b5656c68:88)
    at Object.0 (registerServiceWorker.js:108)
    at __webpack_require__ (bootstrap 39db4eed0e38b5656c68:678)
    at bootstrap 39db4eed0e38b5656c68:724
    at bootstrap 39db4eed0e38b5656c68:724
```

I tried updating my react since the guide mentioned i need 16.3 at least, and i only had 16.0.0.

However after updating react to the newest version it still says the same thing. I can’t seem to find any information about it in the release notes on github.

This is my createContext function:

```

const OrderListContext = React.createContext(DefaultState);


```

And this is where i consume it:
```
<OrderListProvider>
                <OrderListConsumer>
                    {function (value) {
                        const { orderList } = value
                        return (
                            <ul>
                                {orderList.map(listing => (
                                    <li>{listing.varetitle}</li>
                                ))}
                            </ul>
                        )
                    }}
                </OrderListConsumer>
            </OrderListProvider>


```
This is my package.json
```
{
  ""name"": ""React_Demo"",
  ""version"": ""0.1.0"",
  ""private"": true,
  ""dependencies"": {
    ""bootstrap"": ""^4.3.1"",
    ""react"": ""^16.11.0"",
    ""react-bootstrap"": ""^0.32.4"",
    ""react-dom"": """"^16.11.0"""",
    ""react-router-bootstrap"": ""^0.25.0"",
    ""react-router-dom"": ""^5.1.2"",
    ""react-scripts"": ""3.2.0"",
    ""rimraf"": ""^3.0.0""
  },
  ""scripts"": {
    ""start"": ""rimraf ./build && react-scripts start"",
    ""build"": ""react-scripts build"",
    ""test"": ""react-scripts test --env=jsdom"",
    ""eject"": ""react-scripts eject""
  }
}
```
I have recreated my code in stackblitz without data from a fetch funktion: https://stackblitz.com/edit/react-ssqc4t It doesn't seem to show the error so i don't understand why my code doesn't work in visual studio 2017

I have also tried to verify and clear my npm cache, but it still shows the same error.

Node.js have also been updates to the newest version. Still the same error.

",Support
17332,0.0,Other,17332,"useTransition: After startTransition, it does not react to passed props changes",NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**
Probably a bug
**What is the current behavior?**
After firing startTransition, ""current"" component stops reacting to passed props changes while reacting to local state changes.
**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**

In the following CodeSandBox, `count` is counting up in the parent component using `setInterval` but if we click ""CLICK ME"", it suddenly stops updating.
https://codesandbox.io/s/usetransition-stop-reacting-passed-props-updates-p9k1b

**What is the expected behavior?**
When passed props change, it should show the latest value of it where possible

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
Experimental build (0.0.0-experimental-5faf377df)",Bug
17431,0.0,Other,17431,"[react-test-renderer] ""Warning: Each child in a list should have a unique ""key"" prop.""",NONE,"Hello!

**react-test-renderer** works just fine, but I'm getting the following Warning on all of my Tests:

> Warning: Each child in a list should have a unique ""key"" prop.

Has this been addressed? It isn't something related to my code or Tests.

Many thanks!",Support
17517,0.0,Other,17517,Stale values for useState inside callback functions,NONE,"<!--
  Note: if the issue is about documentation or the website, please file it at:
  https://github.com/reactjs/reactjs.org/issues/new
-->

**Do you want to request a *feature* or report a *bug*?**
potential bug

**What is the current behavior?**
When calling `setState` from `useState`, the `state` value is stale from inside a function. The value is correct inside the body of the component, but not inside the function itself.

**If the current behavior is a bug, please provide the steps to reproduce and if possible a minimal demo of the problem. Your bug will get fixed much faster if we can run your code and it doesn't have dependencies other than React. Paste the link to your JSFiddle (https://jsfiddle.net/Luktwrdm/) or CodeSandbox (https://codesandbox.io/s/new) example below:**
Begin by typing `a@g` which should autocomplete to `a@gmail.com`. You will see the `expected` and `actual` values for the input below each.
https://codesandbox.io/s/useemailautocomplete-material-ui-04423

**What is the expected behavior?**
It should have the correct value for `email` inside the `handleChange` function.

**Which versions of React, and which browser / OS are affected by this issue? Did this work in previous versions of React?**
React: `v16.12.0`
Browser: chrome
OS: Catalina",Support
17677,1.0,Support,17677,How can i create a dynamic ENum,NONE,"This request asking about existing features supported by ReactJS. I have an enum in use on several reactJS pages(200 implementations across 32 code files). Now the requirement is to make it dynamic. I am not sure how can i achieve it in ReactJS+REDUX implementation. 

I am working on the latest version of ReactJS",Other
17911,1.0,Support,17911,Bug: startTransition suspends immediately when useLayoutEffect is present,NONE,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version: 0.0.0-experimental-f42431abe

Please note that I do realize my repro steps are poor at best. I'm *not* filing this issue in hopes of support; I'm only filing this issue to provide one more datum point to help diagnose what I believe to be a bug, which I'm assuming you'll see more reports of.

## Steps To Reproduce

tl;dr - there are some circumstances when a thrown promise inside a hook causes an immediate suspense, instead of respecting the startTransition it's inside of.

startTransition for me is always, in this case, called outside of the normal React handlers. In this case history.listen

https://github.com/arackaf/booklist/blob/special/suspense-blog/react/modules/books/booksSearchState.ts#L75

This is my Suspense-enabled hook that's called as a result of the state update inside the code above

https://github.com/arackaf/micro-graphql-react/blob/feature/suspense/src/useQuery.js#L22

the Promise throwing happens here

https://github.com/arackaf/micro-graphql-react/blob/feature/suspense/src/queryManager.js#L116

Here's the specific chain of events that leads to the breakage. 

Things work so long as there's always been an existing promise, for the queryManager to throw, ie line 116 in the code immediately above. But the minute there's cached results, and the queryManager invoke's the hook's setState method (which it passed it), ie line 120 here

https://github.com/arackaf/micro-graphql-react/blob/feature/suspense/src/queryManager.js#L120

then all future suspenses immediately start suspending, and I always get my fallback, always.

The setState method is shared between the hook, and queryManager here

https://github.com/arackaf/micro-graphql-react/blob/feature/suspense/src/useQuery.js#L17

I stress that I do *not* need support, here; this is just a side project, an unimportant one, and this whole branch is only for Suspense experimenting. But something does definitely appear to be wrong, and I'm hoping this report can help you guys find it.

## The current behavior

startTransition only works until the hook's setState is called from the queryManager it creates, at which point startTransition always triggers hard suspenses, showing my fallback.

## The expected behavior

startTransition should never trigger the fallback until the timeout has expired. 
",Bug
17927,1.0,Support,17927,Bug: Autocomplete not working for controlled input,NONE,"React version: 16.12.0

## Steps To Reproduce
1. Have a form with controlled input (i.e. value is set through `onChange` handler)
1. Type `cheese` into the input
1. Submit the form
1. Reload the page
1. Focus the input, type `c`
1. `cheese` is *not* suggested

https://codesandbox.io/s/ancient-currying-oqgt6

It works when a uncontrolled input is used (i.e. value is not set by react `onChange` handler)
1. Have a form with uncontrolled input
1. Type `cheese` into the input
1. Submit the form
1. Reload the page
1. Focus the input, type `c`
1. `cheese` is being suggested

https://codesandbox.io/s/naughty-dijkstra-p3n42

It's not about autofilling address data or passwords, but data previously filled in by the user.
We noticed this issue in Chrome, Firefox and Safari. Even though we could not get any autocompletion to work in Safari, even without React. (We could in Chrome and Firefox)

Thanks!",Bug
17953,0.0,Other,17953,Bug: useReducer runs the queued updates with new props,NONE,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version: 16.8.0

## Steps To Reproduce

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://codesandbox.io/s/usereducer-wfcmq Link to codesandbox.

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Initially step is 0. So for every step react does not rerender due to this https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberHooks.js#L1347. But state updates are queued. So when `step` changes all the state updates are done and hence creates a bug by adding the new step prop.

https://overreacted.io/a-complete-guide-to-useeffect/#why-usereducer-is-the-cheat-mode-of-hooks",Bug
18183,3.0,Feature,18183,useMutableSource and hydration,COLLABORATOR,"Follow up to PR #18000 and RFC https://github.com/reactjs/rfcs/pull/147

The new `useMutableSource` hook will need at least one additional API to be able to support server rendering and hydration. This API would likely be on the React root (the object returned by `createRoot`) and would enable mutable sources to have their versions eagerly captured before hydration begins.

##### How is the version used?

Currently a work-in-progress version of each mutable source is stored on the source itself. This version enables us to [avoid tearing before a source has been subscribed to](https://github.com/bvaughn/rfcs/blob/useMutableSource/text/0000-use-mutable-source.md#reading-from-a-source-before-subscribing). This version number is lazily populated (the first time a source is read during a given render).

##### How will the version be used during hydration?

In the case of server rendering, this version will need to be eagerly populated for every source so that we can detect tearing between the version of the source used for the server respond, and the version we will eventually read from while hydrating on the client.

##### How will this work?

One way to do this would be to store an array on each React root of mutable source and version number pairs. Each time we start (or resume) hydration, we can iterate through this array and use it to initialize the work-in-progress version for each source.

Once all outstanding hydration work is finished, we can clear the array. (Although this will require an additional change as we do not currently have a way to detect that we've finished all pending hydration work.)",Bug
18205,1.0,Support,18205,Bug: backend.js Uncaught TypeError: Cannot read property 'sub' of undefined,NONE,"```
backend.js:32 Uncaught TypeError: Cannot read property 'sub' of undefined
    at g (backend.js:32)
    at e (backend.js:8)
```

It happens when a server returns a string without HTML. I suppose React dev tools expect DOM.

![Screenshot 2020-03-03 at 21 43 42](https://user-images.githubusercontent.com/66249/75817818-18c1fd00-5d98-11ea-89f5-547e97c44632.png)

",Bug
18426,1.0,Support,18426,Call all functions twice in StrictMode,COLLABORATOR,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version: 16.3-16.13

## Steps To Reproduce

1. Render function component with side-effects and without hooks in StrictMode
2. Component only renders once


Link to code example: https://codesandbox.io/s/strictmode-w-and-wo-hooks-vgxvh


## The current behavior

StrictMode only renders function components with hooks twice following https://github.com/facebook/react/issues/15074#issuecomment-471197572


## The expected behavior

I think making [the distinction between components with and without hooks causes more confusion than it helps](https://github.com/mui-org/material-ui/issues/20313). Especially since the docs do not mention this. I amended [past efforts to improve the StrictMode docs](https://github.com/reactjs/reactjs.org/pull/2515) but since this has been ignored I'm not sure this helps. I would also work on making the behavior consistent across all function component types if this is possible.
",Feature
18512,1.0,Support,18512,Bug: dev tools development script is running production build,CONTRIBUTOR,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

**React Dev Tools version**: 4.6.0

I'm not sure there is a problem with `package.json` within`react-devtools-extensions` package, or it's just my misunderstand how it works, but script `build:dev` create production build. 
Command above runs a each script (per browser) in which `NODE_ENV`  is set to `production`.

## Steps To Reproduce

1. Just run `yarn build:dev` in `react-devtools-extensions`
2. It creates minified version of files.


https://github.com/facebook/react/blob/master/packages/react-devtools-extensions/package.json

```javascript 
 ""scripts"": {
    ""build"": ""cross-env NODE_ENV=production yarn run build:chrome && yarn run build:firefox && yarn run build:edge"",
    ""build:dev"": ""cross-env NODE_ENV=development yarn run build:chrome && yarn run build:firefox && yarn run build:edge"",
    ""build:chrome"": ""cross-env NODE_ENV=production node ./chrome/build"",
    ""build:chrome:crx"": ""cross-env NODE_ENV=production node ./chrome/build --crx"",
    ""build:chrome:dev"": ""cross-env NODE_ENV=development node ./chrome/build"",
    ""build:firefox"": ""cross-env NODE_ENV=production node ./firefox/build"",
    ""build:firefox:dev"": ""cross-env NODE_ENV=development node ./firefox/build"",
    ""build:edge"": ""cross-env NODE_ENV=production node ./edge/build"",
    ""build:edge:crx"": ""cross-env NODE_ENV=production node ./edge/build --crx"",
    ""build:edge:dev"": ""cross-env NODE_ENV=development node ./edge/build"",
    ""test:chrome"": ""node ./chrome/test"",
    ""test:firefox"": ""node ./firefox/test"",
    ""test:edge"": ""node ./edge/test""
  },
```

## The current behavior
`""build:dev"": ""cross-env NODE_ENV=development yarn run build:chrome && yarn run build:firefox && yarn run build:edge""` where `build:<browser>` has  `NODE_ENV` set to `production`.

## The expected behavior
Each step in `build:dev` should be replaced from `build:<browser>` to `build:<browser>:dev`


",Bug
18669,0.0,Other,18669,Add More Fuzz Tests,MEMBER,"There’s some things we don’t have a sufficient coverage of. Currently we catch them from production product bugs but this is not sustainable. We’re hoping some refactors will drastically simplify the model — but nevertheless we should invest in better fuzz test coverage. That’s how we caught similar bugs before at an earlier stage.

One thing we’re lacking coverage for is what happens to Suspense boundaries as updates are dispatched at different priorities in different order, and what happens when we’ve had to yield. We need to verify that Suspense always “wakes up” when Promises are resolved and there’s nothing to be suspended on. We also need to test this in combination with render phase updates. 

Here’s examples of bugs that I want a fuzzer to catch: https://github.com/facebook/react/issues/18657 https://github.com/facebook/react/issues/18020 https://github.com/facebook/react/issues/18486 https://github.com/facebook/react/issues/18357 https://github.com/facebook/react/issues/18353 https://github.com/facebook/react/issues/18644 https://github.com/facebook/react/pull/18412. 

@dubzzz I believe you were interested in this? This would take some effort but would be a major contribution. ",Feature
18821,1.0,Support,18821,Bug: ARIA Attribute Reflection,NONE,"React version: 16.13.1

## Steps To Reproduce

1. Implement the [gov.uk ""breadcrumbs"" component](https://design-system.service.gov.uk/components/breadcrumbs/) in React.
2. Use the [ARIA 1.2](https://www.w3.org/TR/wai-aria-1.2/#idl-interface) `ariaCurrent` property, as available in Edge 81, Chrome 81, and Safari 13.
3. See warning:
   ```
   Warning: Invalid ARIA attribute `ariaCurrent`. Did you mean `aria-current`?
   ```

Link to code example: [https://codesandbox.io/s/bold-glitter-lpfpq](https://codesandbox.io/s/bold-glitter-lpfpq?file=/src/App.js)

```jsx
function Breadcrumbs() {
  return (
    <ol>
      <li>
        <a href=""/"">
          Home
        </a>
      </li>
      <li>
        <a href=""/passports"">
          Passports, travel and living abroad
        </a>
      </li>
      <li ariaCurrent=""page"">
        Travel abroad
      </li>
    </ol>
  );
}
```

These properties are helpful reflections that will also be followed by implementations of [`aria*Elements` properties](https://w3c.github.io/aria/#reflection) which would eliminate the need for an `id` by every reference. This is _not_ a bug report on the support of those properties, but they are mentioned to present the higher value these properties will have over dash-less shorthands. I would (naively) expect these (more simple) reflections to worthy of support on their own merits of being implemented web standards.

## The current behavior

The `ariaCurrent` property is not applied, an `ariacurrent` attribute is applied, and a warning is displayed in development.

 ```
 Warning: Invalid ARIA attribute `ariaCurrent`. Did you mean `aria-current`?
 ```

## The expected behavior

The `ariaCurrent` property is applied.",Other
18831,0.0,Other,18831,"Error: ""Commit tree does not contain fiber 256. This is a bug in React DevTools.""",NONE,"Describe what you were doing when the bug occurred:
1. Profiling a slow component
In a component that rendered 5000 pre tags with single lines of text in them, that has an unrelated controlled text box is the same component that was typed into while profiling. App hung a while and, when it rendered again the error was in the profiler.

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.6.0-6cceaeb67

Call stack: at j (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:40:162825)
    at N (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:40:161628)
    at e.getCommitTree (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:40:164582)
    at ec (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:40:339280)
    at ci (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32:59620)
    at Ll (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32:109960)
    at qc (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32:102381)
    at Hc (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32:102306)
    at Vc (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32:102171)
    at Tc (chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/main.js:32:98781)

Component stack: in ec
    in div
    in div
    in div
    in So
    in Unknown
    in n
    in Unknown
    in div
    in div
    in rl
    in Ze
    in fn
    in Ga
    in _s",Bug
19006,0.0,Other,19006,Bug: ReactPartialRenderer function createOpenTagMarkup calls isCustomComponent for every property unnecessarily,NONE,This is a performance issue. Function isCustomComponent is called multiple times for each property of the same component inside of createOpenTagMarkup function (ReactPartialRenderer.js).,Bug
19151,1.0,Support,19151,React Developer Tool Is not working in my localhost. It was working fine before.,NONE,"Hi Team

I am not able to use the react developer tool extension on my chrome browser, Which was working well before.  I have tried by removing and re adding the extension again. Still the problem persists.

I have attached a screenshot of the tool Icon on browser. I am very new to react Environment. Appreciate your help here.

Thank you.

![image](https://user-images.githubusercontent.com/28383863/84981630-8f6de500-b152-11ea-909f-f386f226d7ee.png)
",Bug
19229,2.0,Bug,19229,CI missing failing tests?,COLLABORATOR,"PR #19222 recently landed with no CI failures, but `ReactDOMServerSelectiveHydration` was definitely broken as a result of this PR (and was subsequently fixed in #19227). This is just a reminder for one of us to dig into why CI didn't catch this failure.",Other
19662,0.0,Other,19662,Add a toggle for Boolean props in DevTools,MEMBER,"We previously had a feature where Boolean props would show a checkbox to the left of them in the DevTools pane. It was removed when the JSON editor was added, but I think we should add it back. It should work like this:

1. If the value is a boolean, the checkbox should show up to the left of `true` / `false` value
2. If it's no longer a boolean (e.g. gets edited manually), the checkbox disappears",Feature
19747,0.0,Other,19747,Bug: Using opacity as a percentage value in a css file will become 1% in the production build.,NONE,"Using opacity as a percentage value in a css file will become 1% in the production build version, even though in the localhost website it will appear correctly. The way around this is to use a decimal value (ex. 0.95) for opacity.

React version: 16.13.1

## Steps To Reproduce

1. Set a css class to have a percentage opacity value (ex. 95%)
2. run npm run-scrips build
3. build version will have incorrect percentage (1%)

code example:

.App {
  font-family: sans-serif;
  text-align: center;
  opacity: 50%;
}


## The current behavior
Opacity will change from any percentage value to 1% in app build version.

## The expected behavior
Opacity will stay the same percentage in build version.
",Bug
19861,1.0,Support,19861,"Error: ""child is undefined""",NONE,"Hi! I was developing a next.js app, then I open the dev tools to see the state of some component, and the react dev tools give this error, after a page refresh all when back to normal, I don't know if this is a bug caused by me or is something related to the dev tools itself, so I prefer to report it, if this my fault I'm very sorry for the trouble!

---------------------------------------------
Please do not remove the text below this line
---------------------------------------------

DevTools version: 4.8.2-fed4ae024

Component stack: List@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:20924:30
div
AutoSizer@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:2786:19
div
div
Tree_Tree@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:26368:45
div
div
InspectedElementContextController@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:26848:18
OwnersListContextController@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:25520:18
SettingsModalContextController@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:26139:18
Components_Components@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:30926:50
ErrorBoundary@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:27172:33
PortaledContent@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:27303:27
div
div
ProfilerContextController@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:30463:18
TreeContextController@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:22538:18
SettingsContextController@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:23040:22
ModalDialogContextController@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:28328:18
DevTools_DevTools@moz-extension://e8970055-c8eb-4403-952e-40ddc0e5c62a/build/main.js:33797:16",Other
20022,0.0,Other,20022,Bug: useRef forget '()',CONTRIBUTOR,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version:

## Steps To Reproduce

1.
2.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://codesandbox.io/s/dazzling-heyrovsky-18u9w?file=/src/App.js
<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
correct execution
## The expected behavior
not correct execution

should we do something, such as a warning?To remind us that we forgot about this Brackets",Support
20070,1.0,Support,20070,"Bug: Property expression of JSXExpressionContainer expected node to be of a type [""Expression"",""JSXEmptyExpression""] but instead got undefined",NONE,"React version: 17.0.0
Next.js version: 9.5.5
TypeScript version: 4.0.3

## The current behavior

In a Next.js project using styled-jsx I get the following error across different components that create a `<style jsx>` tag to generate CSS selectors within template literals (or import such styles from a separate file):
```
Property expression of JSXExpressionContainer expected node to be of a type [""Expression"",""JSXEmptyExpression""] but instead got undefined
```
The error appears as soon as I update `react` and `react-dom` to 17.0.0, all other dependencies remain at the version they have been beforehand.

## The expected behavior

It renders the component as expected without any errors.",Other
20334,0.0,Other,20334,Bug: Strange lines in the page,NONE,"When chrome devtools is opened, some strange lines appear in the page and disappear after disable&enable the react extension.
I'm wondering if there are some bugs on react extension.
Win10x64 Chrome 87.0.4280.66
[Chrome issue 83155766](https://support.google.com/chrome/thread/83155766)
![img](https://storage.googleapis.com/support-forums-api/attachment/thread-83155766-2167922176753088865.jpg)",Support
20339,1.0,Support,20339,"Improved ""memory leak"" warning",NONE,"Dear React Maintainers,

My proposal to improve the [""memory leak"" warning](https://github.com/facebook/react/blob/e6a0f276307fcb2f1c5bc41d630c5e4c9e95a037/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L3096) has quite a long background, so let me first thank you for keeping React alive and well. You are all fabulous 🎉

### TL;DR

A Promise is not cancellable, so there is 90% chance that no memory leaks will be fixed when a user applies a ""solution"" to this warning from the internet. This warning encourages a pit of failure (more complex code without removing actual memory leaks) and I argue the detection of memory leaks should be changed.

Table of contents: <a href=""#good"">The good</a> (<a href=""#solutions"">Intended Solutions</a>) - <a href=""#bad"">The bad</a> - <a href=""#uncanny"">The uncanny</a> - <a href=""#proposal"">Proposal</a>

# The good <a name=""good""></a>

> Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.

There were, obviously, good reasons to introduce this warning in the first place. React can't detect memory leaks directly, so this was the next best thing to detect forgotten imperatively attached DOM event handlers or uncancelled WebAPIs. The warning itself does not list any examples, so let me illustrate with [my own bad example](https://codesandbox.io/s/immutable-sun-fo3nt?file=/src/App.js):

```js
const [tick, setTick] = useState(0)
useEffect(() => {
  setInterval(() => setTick(t => t+1), 1000)
}, [])
```

And the intention of the warning is to gently guide the developer to figure out, on their own, what cleaning up means. 

## Intended Solutions <a name=""solutions""></a>

Let me list a few ideas how I think the memory leaks should be solved.

For the *setInterval* (or *setTimeout*):

```js
const [tick, setTick] = useState(0);
useEffect(() => {
  const interval = setInterval(() => setTick(t => t + 1), 1000)
  return () => clearInterval(interval)
}, []);
```

*Aborting a fetch*:

```js
const [data, setData] = useState(null);
useEffect(() => {
    const {signal, abort} = new AbortController()
    fetch('...', {signal}).then(r => r.json()).then(setData)
    return abort
}, []);
```

Replacing closure references to the dispatch function inside `.then(...)` when *dealing with an uncancellable Promise*:

```js
const [data, setData] = useStateIfMounted(null)
useEffect(() => {
  myGenericPromise.then(setData)
}, [])

...

function useStateIfMounted(initialValue) {
  const [state, setState] = useState(initialValue)
  const setterRef = useRef(setState)
  const setterIfMounted = useCallback((...args) => setterRef.current(...args), [])
  useEffect(() => {
    return () => {
      setterRef.current = () => undefined
    }
  }, [])

  return [state, setterIfMounted]
}
```

Note the last one is basically recreating the `no-op` done internally by React (if my understanding is in the right ballpark).

# The bad <a name=""bad""></a>

Now, the same buggy code causes a [completely different warning in tests](https://github.com/facebook/react/blob/e6a0f276307fcb2f1c5bc41d630c5e4c9e95a037/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L3354) (at least in most cases I checked, not sure if always):

>  Warning: An update to MyComponent inside a test was not wrapped in act(...).

Let's ignore that for a second and try to analyze the solutions that developers can find for the ""memory leak"" problem on the internet. 

1.) `isMounted` variants, like in most of the top answers on [StackOverflow](https://stackoverflow.com/search?tab=votes&q=%22perform%20a%20React%20state%20update%20on%20an%20unmounted%20component%22) or various learning materials such as Kent's [useSafeDispatch](https://github.com/kentcdodds/advanced-react-hooks/blob/560980b10fd10e66fcf5e4f5b4b90bf46cb5fc7b/src/utils.js#L3)

=>❌ These solutions only address the warning, not solving any memory leaks (presumably, they focus on making the warning go away if it's a false positive). The code is more complex without any benefit. An example of shutting up the warning without solving the leak:

```js
const [tick, setTick] = useState(0)
const isMounted = useRef(true)
useEffect(() => {
  setInterval(() => isMounted && setTick(t => t+1), 1000) // ❌ please don't run infinite intervals at home
  return () => isMounted.current = false
}, [])
```

2.) fake cancellation like at the end of [isMounted is an Antipattern](https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html) or the cancel method from the [react-async library](https://github.com/async-library/react-async/blob/129385c7477c9c6b5ad9c4ea96220779478a1ff6/packages/react-async/src/useAsync.tsx#L230-L231)

=>❌ These look like valid solutions on a first look, but they actually leave the closure references untouched, so not solving any memory leaks either. JS Promise is simply not cancellable (yet?), and no amount of sophistication will allow garbage collection of closures of the function used for the `.then(...)` callback while the Promise is still pending - it is not possible to modify the original Promise, only to create a new Promise. The code is much more complex without any benefit. (see <a href=""#uncanny"">The uncanny</a> section for details)

3.) real cancellation like https://stackoverflow.com/a/54964237/1176601

=>✔ Aborting a fetch request and other operations that enable garbage collection.
=>❌ But it's very hard to figure it out from the available advice - ""memory leaks"" is not the best documented topic for JavaScript...

# The uncanny <a name=""uncanny""></a>

My statement about fake cancellations (2. above) could be controversial, so let me elaborate:

As far as I can tell, the `makeCancellable` utility from the end of https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html as well as _all_ proposed solutions in https://github.com/facebook/react/issues/5465 , https://github.com/reactjs/reactjs.org/issues/1082 and https://github.com/facebook/react/issues/15006 suffer from the same memory leaks as a naive solution would:

```js
// naive
const [value, setValue] = useState()
useEffect(() => {
  myPromise.then(setValue)
}, [])
```

This naive solution can trigger the warning (as a race condition during unmount), while the complicated solutions won't. Both leak the exact same amount of memory references - functions that we know will never be used but the JS engine cannot garbage collect - because a closure reference to them still exists.

Let me illustrate on a modified example that can be executed in the console => the `cancelablePromise` will be rejected after 2 seconds, so the reference from `then` to the function that was a value of the `setValue` variable will exist for exactly as long as in the naive solution:

```js
const cancelablePromise = makeCancelable(
  new Promise(r => setTimeout(r, 2000))
);
const setValue = () => undefined

cancelablePromise
  .promise
  .then(setValue)
  .catch((reason) => console.log('isCanceled', reason.isCanceled));

cancelablePromise.cancel(); // Cancel the promise

function makeCancelable(promise) {
  let hasCanceled_ = false;

  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then(
      val => hasCanceled_ ? reject({isCanceled: true}) : resolve(val),
      error => hasCanceled_ ? reject({isCanceled: true}) : reject(error)
    );
  });

  return {
    promise: wrappedPromise,
    cancel() {
      hasCanceled_ = true;
    },
  };
};
```

As for the `cancel` method in https://github.com/async-library/react-async/blob/129385c7477c9c6b5ad9c4ea96220779478a1ff6/packages/react-async/src/useAsync.tsx#L230-L231, that is even more complicated, but my intuition says that a reference to `dispatch` will continue to exist after `cancel()` as long as the `promiseFn` is pending - because the `cancel` function does not clear `lastPromise.current`...

# Proposal <a name=""proposal""></a>

## Option 1: small tweak

How about flipping [this condition](https://github.com/facebook/react/blob/e6a0f276307fcb2f1c5bc41d630c5e4c9e95a037/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L3121) `if (didWarnStateUpdateForUnmountedComponent.has(componentName)) return;` the other way round? If some code tries to update the state of an unmounted component just once, ignore it.

Sweep the little insignificant memory leak under the carpet (remember, I argue that it is more likely that an attempt to fix the warning will NOT fix any memory leaks, so remaining quiet is not such a bad option and the memory will be freed at the same time with or without this warning - but the user code will be much simpler if they don't attempt to fix this warning).

On the other hand, if the state update happens repeatedly after the unmounting (e.g. setInterval or observable stream), that is a very clear signal that the memory leak is more serious => the warning is much more useful in this situation. It might require some re-wording + a link to examples how to fix it correctly.

However, I am not sure about the related `not wrapped in act(...)` warning in tests. Changes to one warning might require synchronization of both warnings for consistency...

## Option 2: detect the memory leaks in Dev Tools

In an ideal world, it should be possible to trigger browser garbage collection from inside React Dev Tools code in all supported browsers. That might not be the case in the real world, but please stay with me for 1 more minute: both supported browsers are open source and they both expose the tools to trigger garbage collection in GUI => some API must exist and it should be possible to expose it in a browser extension.

Now, if React Profiler could trigger GC reliably after pressing the stop profiling button, then we can use an array of [WeakRef](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)s to find all references to the dispatchers (or other objects) of unmounted components that leaked in some closure somewhere. Pseudocode:

```js
const zombies = []

function unmountComponent(node) {
  dispatchZombies.push(new WeakRef(node))
}

function stopProfiling() {
  gc()
  warningAboutZombies.nodes = zombies.map((ref => ref.deref()).filter(Boolean)
}
```

## Option 3: React.getZombies()

Expose some method to get a list of ""undead zombie references"" in tests, that would be available when running in Node with the `--expose-gc` flag...",Other
20450,0.0,Other,20450,Bug: Trailing Comma in Arrays and Dict,NONE,"The learn react tic tac toe game tutorial shows a trailing comma at the end of dictionary values. This is known to cause issues with Internet Explorer. Hoping you can change that.

https://stackoverflow.com/questions/5139205/javascript-can-a-comma-occur-after-the-last-set-of-values-in-an-array

React version:  LTS

## Steps To Reproduce

1. Run tic tac toe tutorial code

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
Internet Explorer throws weird errors

## The expected behavior
Internet Explorer loads the tic toe game without any ussyes",Support
20590,1.0,Support,20590,"Bug: react-test-renderer provides no equivalent to attachTo option of Enzyme, mandatory to snapshot Leaflet and other",NONE,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version: 16.13.1

## Steps To Reproduce

1. In a project with React, and react-leaflet@2.7.0
2.
```ts
import React from ""react"";
import Renderer from ""react-test-renderer"";
import { Map, TileLayer } from ""react-leaflet"";

let component = Renderer.create(
    <Map>
      <TileLayer
        attribution='&copy; <a href=""http://osm.org/copyright"">OpenStreetMap</a> contributors'
        url=""https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png""
      />
    </Map>
  );
```

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example: https://codesandbox.io/s/react-test-renderer-leaflet-mohzp
<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

It raise an error `Map container not found.`

## The expected behavior

Enzyme's `attachTo` option allow to mount the comment in a more realistic environment, which fixes this bug. But there is no equivalent feature in `react-test-renderer` as far as I know.

See https://github.com/PaulLeCam/react-leaflet/issues/246 for more info about the Enzyme fix for this issue.

It should render the map as expected.",Other
20841,0.0,Other,20841,Mixin rewrite with React and Higher-order-functions,NONE,"@gaearon How would you re-write the following mixins?

https://github.com/gerobit/ivis-core/blob/a51154c8937d4d392f20303caeb8b450ecf9189a/client/src/lib/decorator-
helpers.js",Support
21098,0.0,Other,21098,Bug: aspectRatio not being applied via style,NONE,"React version: 16.14.0, 17.0.2

## Steps To Reproduce

1. Apply aspectRatio via `style` - no aspectRatio applied
2. Add via className - aspectRatio applied

Needs Chrome 79 or above:
Link to code example: https://codesandbox.io/s/react-bug-not-applying-aspect-ratio-via-style-w2pqh?file=/src/App.js

## The current behavior

No aspectRatio rule applied:
https://codesandbox.io/s/react-bug-not-applying-aspect-ratio-via-style-w2pqh?file=/src/App.js


## The expected behavior

aspectRatio applied, here I'm adding it via a `useLayoutEffect`:
https://codesandbox.io/s/currying-hill-i09qn?file=/src/App.js
",Support
21191,0.0,Other,21191,useCallback memoization,NONE,"I want to continue a discussion about the `useCallback` that started on twitter (https://twitter.com/ramon_fritsch/status/1379569928454303749) here, following @gaearon's suggestion.

It's about `useCallback` returning a new reference when dependencies change. I always wondered if that's what we usually want.

Take this example: https://codesandbox.io/s/sipxs

I understand `useCallback` is intended to use on event handlers and regular callback props, thus we need to make it as flexible as possible. But the case for event handlers, I'd suggest to have a new hook `useEventCallback` that would memoize the callback function forever and never return a new reference, helping in not causing a re-render down the chain.

The folks from Formium solved this with https://github.com/formium/formik/blob/2d613c11a67b1c1f5189e21b8d61a9dd8a2d0a2e/packages/formik/src/Formik.tsx#L1193-L1205

Isn't it important enough to become a core hook in the React ecosystem? Or at least have a clear statement in the documentation about this behavior and best practices for event handlers?
",Support
21371,1.0,Support,21371,Bug: calling calling `setState` twice inside `useEffect` creates extra function calls,NONE,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version: 17.0.2

## Steps To Reproduce

1. Create a function component
2. Call 2 `setState` functions inside a `useEffect` hook.

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

```tsx
import { FC, useEffect, useState } from 'react'

const resolvedPromise = Promise.resolve()

const Test: FC = () => {
  const [a, setA] = useState(2)
  const [b, setB] = useState(0)

  useEffect(() => {
    let canceled = false

    resolvedPromise.finally(() => {
      console.log(a, b, canceled)
      if (canceled) return
      if (a > 0) {
        setA(a - 1)
        setB(b + 1)
      }
    })

    return () => {
      canceled = true
    }
  }, [a, b])

  return null
}
```

Link to code example: https://codesandbox.io/s/react-bug-606s4?file=/src/App.tsx

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior
- `b` ends up being `1`.
- There is an extra function call when `a` is `1` and `b` is `0`. I think this is after `setA(a - 1)` but before `setB(b + 1)`.
- The function call with `1 0 false` was not canceled.
- The function call with `1 1 true` was canceled.

Current console output:
```
2 0 false
1 0 false 
1 1 true
0 1 false
```
## The expected behavior
- `b` ends up being `2`
- No extra function call in between `setA()` and `setB()`

Expected console output:
```
2 0 false
1 1 false
0 2 false
```
",Other
21390,0.0,Other,21390,Bug: Cannot read property __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED of undefined,NONE,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

# I got this issue when using react in deno deploy, but i think it will still throw this error in nodejs

## Code: https://github.com/code913/react-ssr-deno

![what the heck is this tbh](https://user-images.githubusercontent.com/54856929/116580980-82ed1800-a931-11eb-8671-05cb0cde4dfc.png)

React version: 17.0.2 react-dom, react version latest

## Steps To Reproduce

1. Import react-dom from the umd production or development url (havent tested others): `https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.development.min.js`
2. Try to hydrate some data from react-dom/server",Support
21644,0.0,Other,21644,Request for Package Release,NONE,"I'm sorry if this is the wrong place to file this, but I wasn't sure how else to get ahold of the React team. The #21392 by @bvaughn fixes an issue that was causing MobX components to display components in stack traces as `wrappedComponent`, making it very hard to debug issues. This PR was merged back in April, but there hasn't been a React release since March. Is there any chance you guys would be willing to release React 17.0.3 with this fix?

Thanks!",Support
21989,1.0,Support,21989,Bug: createPortal anywhere in the tree makes native events be ran too late,NONE,"## Summary
Native events added via `useEffect` are called too late (and with improper (new) state, rather than the state during listener attachment) if there's a `ReactDOM.createPortal` anywhere in the tree. First the effect is re-run and a new listener is attached, and only then the native event is called.

React version:
17.0.2

Link to code example:

[CodeSandbox](https://codesandbox.io/s/late-star-1izm6)

## Reproduction 

* Anywhere in the tree is a `createPortal`. It can even be `createPortal(null, document.body)`
* Somewhere, there is a component with `useState`.
* It renders a div. The div has an `onClick` handler passed.
* On top of that, `useEffect` is used to attach a `click` event to `window`
* Both event handlers (both the native event attached to window, and the React event passed to `div`) use `setState`.

## The current behavior

* The React handler is called. It calls setState
* The component rerenders with the new state, and its effects are re-run.
* Since the effect is re-run, a new native listener is attached (which is bound to the new state)
* Only then, the new listener (with the NEW state) is called.

## The expected behavior

* The React handler is called. It calls setState
* The component might rerender or not (doesn't matter)
* The native handler is called with the old state.

In other words
```
const [popupOpen, setPopupOpen] = useState(false);
useEffect(() => {
   // close popup if clicked anywhere on the screen, some code ignored for brevity 
  const listener = () => {
    console.log('NATIVE', popupOpen);
    if (popupOpen) setPopupOpen(false);
  };
  window.addEventListener(""click"", listener);
  return () => window.removeEventListener(""click"", listener);
}, [popupOpen]);

return (
  <>
    <div
      onClick={() => {
        console.log('REACT', popupOpen); // REACT HANDLER STATE
        if (!popupOpen) setPopupOpen(true);
      }}
    >
      Open popup
    </div>
    {ReactDOM.createPortal(null, document.body)}
  </>
);
```

Logs

![image](https://user-images.githubusercontent.com/45483493/127549843-763c1ee1-4976-4d7b-855e-91b16b8c4e3e.png)

But without `createPortal`, the following is logged:

![image](https://user-images.githubusercontent.com/45483493/127550018-901aee68-c9d9-4c66-9897-9466789256ce.png)
",Other
22048,1.0,Support,22048,Bug: Cannot set property 'memoizedState' of null with nested renderToStaticMarkup and hooks,NONE,"React version: 17.0.2

## Steps To Reproduce

1. Have a component which memoizes the result of a renderToStaticMarkup.
2. Use renderToStaticMarkup to render the component of 1.

Link to code example:

```
function nestedRender() {
  return renderToStaticMarkup(<p>This is the nested render result</p>);
}

function MyComponent() {
  const nestedRenderResult = useMemo(() => nestedRender(), []); // Removing useMemo will solve the issue
  return <p>The nested result is: {nestedRenderResult}</p>;
}

function wrapperRender() {
  return renderToStaticMarkup(<MyComponent />);
}
```

https://codesandbox.io/s/lingering-shadow-vyqyd

## The current behavior

The application crashes with a TypeError: Cannot set property 'memoizedState' of null

```
Uncaught TypeError: Cannot set property 'memoizedState' of null
    at Object.useMemo (react-dom-server.browser.development.js:1587)
    at useMemo (react.development.js:1532)
    at MyComponent (App.tsx? [sm]:12)
```

## The expected behavior

The result is rendered correctly to a string containing the final markup.

## Context about my use case

The example may seem a bit contrived as nesting renderToStaticMarkups is by no means a common case. However, we use the outer renderToStaticMarkup to do server side rendering of HTML output. The inner renderToStaticMarkup is used to render the content to a string on which we do extra postprocessing after (e.g. Handlebars).",Other
22115,0.0,Other,22115,DevTools: Better Bundle Names for Dynamically Imported Modules,CONTRIBUTOR,"In the DevTools extension, webpack currently uses an automatically assigned ID as the chunk name for dynamically imported modules (ie. `parseHookNames` and associated code will get bundled into `6.js`).

We've tried adding `chunkFilename: '[name].js'` to `output` in `webpack.config.js` and  magic comments (ie.`/* webpackChunkName: ""parseHookNames"" */`) to the dynamic import to fix, but neither works. ",Bug
22133,1.0,Support,22133,refs for function components as first class citizens,NONE,"I'm looking everywhere, but I can't seem to find an official answer.

It seems `ref`s are discouraged, and developers are required to use `forwardRef`, or pass ref as a separate prop (i.e. `forwardRef={ref}`). 
`ref` are very important when access to the DOM is required, usually when a measurement is needed.
Example usages include **tooltips**, graph nodes, animations, and dom observers.

For example, [@tippyjs/react](https://www.npmjs.com/package/@tippyjs/react) assumes children receive a ref (since `findDOMNode` is deprecated), and will simply fail with most components.
Another example is a `ClickOutside` hook, that watches click events and triggers callback which clicking on a dom element outside a specific component.

Lastly, it really complicated component compositions.
Composing components and ultimately forwarding all props down to the DOM allows us to use all components as first class citizens, so they all have the same abilities as a div. I can pass an event handlers, data attribute, tabIndex, etc, to any component, without having to alter it.
```tsx
interface UserMenuProps extends MenuProps {
  users: User[];
}

function UserMenu({users, ...rest}: UserMenuProps) {
  // even if Menu supports ref forwarding, I need to forwardRef again just to keep the same behavior.
  return <Menu {...rest}>
    {props.users.map(x=> <UserItem user={x})}
  </Menu>
}

function SettingsPage(props) {
  const privacyRef = useRef(null);
  const validatePrivacy = () => {...};
  
  useClickOutside(privacyRef, validatePrivacy());

  return <div>
     {/* tooltip is implicitly using ref to target children */}
     <Tooltip content=""this is your user menu!"">
       <UserMenu className=""centered"" />
     </Tooltip>
     {/* PrivacySettings is already getting ref, so tooltip needs an explicit target */}
     <Tooltip content=""select how public you want to be!"" target={privacyRef} />
       <PrivacySettings ref={privacyRef} style={{shadow: ""1px 2px black""}} onClick=(...)/>
     </ Tooltip>
  </div>
}
```

I don't like to use forwardRef because:
* It prevents even the simplest of component from being used in (our) legacy react 15 project.
* The syntax is really complicated, and I need to set the same function name 3 times for each component.
* I don't want to add it to every single component I make. (and force my team to do the same).

I would prefer to use refs as first class citizens, like
```tsx
function Menu(props: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      {...props}
      className={cn(""menu"", props.className)}
      // just to emphasize, I'm getting the ref from the props.
      // I could also apply it to a different element, or pass a completely different object for ref.current, or keep it null
      ref={props.ref}
    />
  )
}
```

I see a hint here - https://github.com/reactjs/rfcs/pull/107#issuecomment-466282354, that refs will finally be first class props in the new JSX transform. Is this true? or will we still be required to use forwardRef?

Most importantly, can I rely on it in projects with the new transform? including legacy project using `React 15.7.0`?",Other
22301,1.0,Support,22301,found an empty rule set ,CONTRIBUTOR,"this is the file path - packages/react-devtools-shared/src/devtools/views/Settings/SettingsShared.css

going here i found a empty rule set called selector which had nothing inside it and it is not a good practice to keep empty ruleset .


here is the PR link for the same - https://github.com/facebook/react/pull/22298

hope to get a feedback soon!",Other
22758,1.0,Support,22758,Some one is changing the state variable from the react devlopment tool in production build?,NONE,,Other
22997,0.0,Other,22997,"Bug: Image source takes a string, but not a variable with the same string",NONE,"I'm using create-react-app

In my App.js, (the standard file created automatically) 

```
//This one works 
function Image(){
    return  <img src={require(""./image.png"").default}/>
}

//This doesn't work
function Image2(){
    let src = ""./image.png"";
    return <img src={require(src).default}/> 
}
```


Seems odd, since src has the same value as the string. Is it maybe a compiler error?

Complete file would be like this

```
import React from 'react';

//This work 
function Image(){
    return  <img src={require(""./image.png"").default}/>
}

//This doesn't work 
/*
function Image2(){
    let src = ""./image.png"";
    return <img src={require(src).default}/> 
}
*/

function App(){
     return <Image/>
     //return <Image2/>
}

export default App;
```

I'm researching, and it might be due to webpack and not react.

Anyway, I'm too inexperienced, I'll leave this, it might be useful somehow. ",Support
23026,0.0,Other,23026,eslint-plugin-react-hooks: exhaustive-deps nagging behaviour,NONE,"In some situations like the following, I can't find an elegant way to deal with exhaustive-deps error. I don't want to disable it just because of that maybe there is room to improve the linter rule here?

```js
const { firstName, lastName, middleName, email, ...(list goes on) } = someData;

const cb = useCallback(() => {
  ...
  someFn({
    firstName,
    lastName,
    middleName,
    ...,
    //(basically a subset of someData with other properties from component context)
  })
}, [someData] // => here I have to list all the variables I destructed from that object instead of just putting someData as dependency. When we assume that we use that destructed variables all over in the component context and they are numberous; dependency list grows long and maybe not so efficient.
```
",Support
23374,0.0,Other,23374,Bug: CustomError: Cannot find module react/jsx-runtime,NONE,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version: 17.0.2

## Steps To Reproduce

Not sure

## The current behavior 
CustomError: Cannot find module react/jsx-runtime

## The expected behavior
No Error

I switch from common js to esm & after done that I am getting this error.
I added `.js` & here is my `tsconfig`

```
""target"": ""es5"",
""module"": ""es2020"",
""lib"": [""dom"", ""dom.iterable"", ""esnext""],
""jsx"": ""react-jsx"",
""moduleResolution"": ""node"",
""allowJs"": true,
""checkJs"": true,
""noImplicitAny"": true,
""noImplicitReturns"": true,
""strictNullChecks"": true,
""strictFunctionTypes"": true,
""noUnusedLocals"": true,
""noUnusedParameters"": true,
""removeComments"": true,
""strict"": true,
""noFallthroughCasesInSwitch"": true,
""allowSyntheticDefaultImports"": true,
""esModuleInterop"": true,
""skipLibCheck"": true,
""forceConsistentCasingInFileNames"": true,
""resolveJsonModule"": true,
""isolatedModules"": true,
""importHelpers"": true
```
",Support
24170,1.0,Support,24170,[React DevTools] Component Stacks for Timeline Profiler,CONTRIBUTOR,"In the Timeline Profiler, we currently denote each state update with a dot. If you hover on the state update, you get some information about it, such as which component caused the update, the lane the update was rendered at, and the time that the update happened. This is useful for unique components. However, for components (ex. library components) that are used in multiple places, just having the component name is less helpful. 

It would be most useful to get a stack of component owners (like in the rendered by section in the Components tab). However, we only have owner metadata in DEV mode, and it usually only makes sense to profile in production. The next best thing we can do, then, is to get all the parent components and create a stack out of that (ie the return path of the fiber rather than the owner path). 

<img width=""1209"" alt=""image"" src=""https://user-images.githubusercontent.com/2735514/160208568-771861d3-59a3-4a82-9719-c8f5663ee574.png"">

We want to add component stacks so that we also know which parent(s) caused the update. For this task, a potential solution is:
* [ ] When a state update happens, walk the fiber's return path and save all the component names and their source. (See `markStateUpdateScheduled` for code pointers on where to put this)
* [ ] After we're done profiling, process the stack so that we create a stack of return fibers
* [ ] Pass the stack to the DevTools front end and add the component stacks to the UI when a user hovers over a state update",Feature
24239,0.0,Other,24239,Bug: App is unresponsive with React 18,NONE,"Before upgrading to react 18 app was working well but after upgrading this is not responding well

React version:18

## Steps To Reproduce

1. Open the application and wait for 2 sec. then see buttons are not clickable
2. After sometime we will see page unresponsive

Link to code example:

Deployed URL : https://app-jitera.netlify.app/



## The current behavior
 As you can see in the screenshot.

## The expected behavior
It should run without lag.

",Support
24280,1.0,Support,24280,Bug: componentWillUnmount is called twice,NONE,"React version: 18.0.0

## Steps To Reproduce

`componentWillUnmount` is called twice upon toggling the rendered component. Even when **StrictMode** is disabled

Link to code example: https://codesandbox.io/s/componentwillunmount-called-twice-hrpzy5?file=/src/App.js

## The current behavior

After upgrading to react 18 we've seen some different behavior in a conditionally rendered, lazy class component. 

In the provided code example the class component is rendered first. After the first toggle, the class component's componentWillUnmount is called twice. 

Subsequent toggle calls correctly lead to a single componentWillUnmount invocation.

This does only seem to affect the class component when its rendered first. If the condition is changed to initially show the other function component the class component unmounts just fine

## The expected behavior

The class component's componentWillUnmount is only called once",Bug
24467,0.0,Other,24467,"Bug: Page renders twice when use ""ReactDOM.createRoot"" in the index.tsx in React 18",NONE,"<!--
  Please provide a clear and concise description of what the bug is. Include
  screenshots if needed. Please test using the latest version of the relevant
  React packages to make sure your issue has not already been fixed.
-->

React version:18.1.0

## Steps To Reproduce

1. create-react-app test-render --template typescript
2. go to  src/App.tsx write useEffect( ) in the function before return, such as ""console.log('app') "" in the callback
3. npm run start
4. checkout the console, you will find this function runs two times
5. if I use the React 17 ,there will be only once print

<!--
  Your bug will get fixed much faster if we can run your code and it doesn't
  have dependencies other than React. Issues without reproduction steps or
  code examples may be immediately closed as not actionable.
-->

Link to code example:
https://github.com/voiceu-zuixin/react18-test-render

<!--
  Please provide a CodeSandbox (https://codesandbox.io/s/new), a link to a
  repository on GitHub, or provide a minimal code example that reproduces the
  problem. You may provide a screenshot of the application if you think it is
  relevant to your bug report. Here are some tips for providing a minimal
  example: https://stackoverflow.com/help/mcve.
-->

## The current behavior

![image](https://user-images.githubusercontent.com/77840482/165945523-d206aa39-9a09-4a75-8827-c399892ea0e4.png)


## The expected behavior
![image](https://user-images.githubusercontent.com/77840482/165945482-4c956b6f-7f88-4fae-8188-5836d7cee08a.png)
",Support
24938,0.0,Other,24938,Use of styled components ?,NONE,,Support
25300,0.0,Other,25300,React Lazy Load not working with variable path,NONE,"I have the same issue when using Lazy Load with variable path.

if I put the path in the variable, I see ""Can't find the module""

``` 
const filePath = `@pages/general/general`;
const component = React.lazy(() => import(`${filePath}`));
```
but if I put the path directly, it's working 
```
  const component = React.lazy(() => import(""@pages/general/general""));
```

any suggestions?

_Originally posted by https://github.com/facebook/react/issues/16132#issue-467840101",Support
25520,0.0,Other,25520,Bug: Github pages not displaying my Vite.js app  ,NONE,"Link to code example: https://github.com/claudeMassaad/TENZIES-GAME-REACT-APP

Here's my main and index.html in Vite app:

![Screen Shot 2022-10-20 at 10 16 31 AM](https://user-images.githubusercontent.com/109232112/196881586-b1023f1c-5173-4200-9395-6c346833aec7.png)
![Screen Shot 2022-10-20 at 10 16 45 AM](https://user-images.githubusercontent.com/109232112/196881627-064570e9-e384-40c1-a44a-6879da8eb0e2.png)

## The current behavior
![Screen Shot 2022-10-20 at 10 15 39 AM](https://user-images.githubusercontent.com/109232112/196881433-8e7d367b-4f93-406d-b262-88627627f5b7.png)

 Once i push to my github and then go to the pages feature on github where github generates a link for my web app, the screen is white and i get this error:Failed to load module script: Expected a JavaScript module script but the server responded with a MIME type of ""text/jsx"". Strict MIME type checking is enforced for module scripts per HTML spec.
Now i cant change the name of main.jsx to main.js because Vite requires .jsx extensions.
Any help?

## The expected behavior


I am running a react app created with Vite.js locally and everything works perfectly when i run npm run dev. It should do the same when github generates a link for my website",Support
